# -*- coding: utf-8 -*-
"""
Created on Tue Dec 14 21:26:56 2021

@author: stijn
"""

import osmnx as ox
import networkx as nx
from gurobipy import *
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from random import randrange
import datetime as dt

#%% Input

#amount of random horeca businesses
hotels          = 1
restaurants     = 3
cafes           = 1

total_number = hotels + restaurants + cafes

#demand of the horeca businesses
hotel_demand        = 3
restaurant_demand   = 2
cafe_demand         = 1

#service time of transshipment locations
service_time_transshipment_locations = 100      #transshipment takes 100 seconds

#service time of when demand = 1
demand_time = 60                                #one demand takes 60 seconds

#average velocity 
v_v   = 3         #vessel [km/h]
v_cb  = 15        #cargo bike [km/h]

#start time daily
start_time = dt.time(9, 0, 0)

#%% Data of depot and transshipment locations

#food center Amsterdam
DEPOT_ID        = [0]
DEPOT_xc        = [4.86710901594967]
DEPOT_yc        = [52.3768425669394]
DEPOT_S_TIME    = [0]
DEPOT_DEMAND    = [0]

#possible transshipment locations
TRANSSHIPMENT_ID        = [1, 2, 3, 4, 5]
TRANSSHIPMENT_xc        = [4.88579832348976, 4.89897053786215, 4.88698073724161, 4.87506869812568, 4.89960310635604]
TRANSSHIPMENT_yc        = [52.3781345840468, 52.3710515837882, 52.3678608025364, 52.3663821064631, 52.3642373469622]

o = service_time_transshipment_locations

TRANSSHIPMENT_S_TIME    = [o, o, o, o, o]
TRANSSHIPMENT_DEMAND    = [0, 0, 0, 0, 0]


#customer_id
CUSTOMER_ID = []
for i in range(6,6+total_number):
    CUSTOMER_ID.append(i)

#%% Input data from excel file generated by using the Google API and count rows

customer_input_hotel        = pd.read_excel (r'C:/Users/stijn/Dropbox/Stijn/Research Project/Python/03 Final models/Google API/Horeca_business_data.xlsx', sheet_name='hotels')
customer_input_restaurant   = pd.read_excel (r'C:/Users/stijn/Dropbox/Stijn/Research Project/Python/03 Final models/Google API/Horeca_business_data.xlsx', sheet_name='restaurants')
customer_input_cafe         = pd.read_excel (r'C:/Users/stijn/Dropbox/Stijn/Research Project/Python/03 Final models/Google API/Horeca_business_data.xlsx', sheet_name='cafes')

hotel_rows          = customer_input_hotel.shape[0]
restaurant_rows     = customer_input_restaurant.shape[0]
cafe_rows           = customer_input_cafe.shape[0]

#%% Pick random hotels, restaurants and cafes

# random_hotels = []
# for j in range(hotels):
#     random_hotels.append(randrange(1, hotel_rows))    

# random_restaurants = []
# for j in range(restaurants):
#     random_restaurants.append(randrange(1, restaurant_rows))

# random_cafes = []
# for j in range(cafes):
#     random_cafes.append(randrange(1, cafe_rows))

#%% Chose hotels, restaurants and cafes

random_hotels           = [302]
random_restaurants      = [290, 227, 754]
random_cafes            = [206]

#%% Get longitudes and latitudes belonging to the horeca businesses

hotel_xc = []
for k in random_hotels:
    hotel_xc.append(customer_input_hotel.iloc[k]['longitude'])

hotel_yc = []
for k in random_hotels:
    hotel_yc.append(customer_input_hotel.iloc[k]['latitude'])

restaurant_xc = []
for k in random_restaurants:
    restaurant_xc.append(customer_input_restaurant.iloc[k]['longitude'])

restaurant_yc = []
for k in random_restaurants:
    restaurant_yc.append(customer_input_restaurant.iloc[k]['latitude'])

cafe_xc = []
for k in random_cafes:
    cafe_xc.append(customer_input_cafe.iloc[k]['longitude'])

cafe_yc = []
for k in random_cafes:
    cafe_yc.append(customer_input_cafe.iloc[k]['latitude'])

CUSTOMER_xc = hotel_xc + restaurant_xc + cafe_xc
CUSTOMER_yc = hotel_yc + restaurant_yc + cafe_yc

#%% Plot OSMnx graph

ox.config(use_cache=True, log_console=True)
waterway_network = ox.graph_from_bbox(52.3869, 52.3565, 4.8614, 4.9356, simplify=False, custom_filter='["waterway"~"canal"]')
bike_network = ox.graph_from_bbox(52.3880, 52.3520, 4.8614, 4.9356, simplify=True, network_type='bike')

#waterway network
nodes1, edges1 = ox.graph_to_gdfs(waterway_network, nodes=True, edges=True)

#bike_network
nodes2, edges2 = ox.graph_to_gdfs(bike_network, nodes=True, edges=True)

#plots
# fig, ax = ox.plot_graph(waterway_network)
# fig, ax = ox.plot_graph(bike_network)

a = 0.0015

#plot graph
fig, ax = plt.subplots(figsize=(15,10), dpi=300)
plt.xlim([4.8614-a, 4.9356+a])
plt.ylim([52.3520-a, 52.3880+a])
plt.title('Amsterdam routing network')
plt.xlabel('Longitude')
plt.ylabel('Latitude')

nodes1.plot(ax=ax, color='brown', markersize=10, alpha=0.3, zorder=2)
edges1.plot(ax=ax, linewidth=1, edgecolor='black', linestyle='dashed', alpha=0.5, zorder=2)
nodes2.plot(ax=ax, color='lightblue', markersize=10, alpha=0.5, zorder=1)
edges2.plot(ax=ax, linewidth=1, edgecolor='grey', alpha=0.5, zorder=1)

#plot depots, transshipment locations and customers
plt.scatter(DEPOT_xc, DEPOT_yc, c='black', marker='s', s=100, zorder=3, label='depot')
plt.scatter(TRANSSHIPMENT_xc, TRANSSHIPMENT_yc, c='grey', marker='s', s=100, zorder=3, label='transshipment location')

plt.scatter(hotel_xc, hotel_yc, c='green', zorder=4, s=30, label='hotel')
plt.scatter(restaurant_xc, restaurant_yc, c='blue', zorder=4, s=30, label='restaurant')
plt.scatter(cafe_xc, cafe_yc, c='red', zorder=4, s=30, label='cafe')

#plot legend without duplicates
handles, labels = plt.gca().get_legend_handles_labels()
by_label = dict(zip(labels, handles))
plt.legend(by_label.values(), by_label.keys())

#%% test section1: get nodes and edges

# writer = pd.ExcelWriter('C:/Users/stijn/Dropbox/Stijn/Research Project/Python/03 Final models/test.xlsx')

# nodes1.to_excel(writer, 'nodes1', header=True)
# edges1.to_excel(writer, 'edges1', header=True)
# nodes2.to_excel(writer, 'nodes2', header=True)
# edges2.to_excel(writer, 'edges2', header=True)

# writer.save()

#%% test section2: plot specific node

# error1 = [52.3781748,   4.8859865]    #nodes2
# error2 = [52.364788,    4.8813924]    #nodes2

# #plot graph
# fig, ax = plt.subplots(figsize=(15,10), dpi=300)
# plt.xlim([4.8614-a, 4.9356+a])
# plt.ylim([52.3565-a, 52.3869+a])
# plt.title('Amsterdam routing network')
# plt.xlabel('Longitude')
# plt.ylabel('Latitude')

# nodes1.plot(ax=ax, color='brown', markersize=10, alpha=0.3, zorder=2)
# edges1.plot(ax=ax, linewidth=1, edgecolor='black', linestyle='dashed', alpha=0.5, zorder=2)
# nodes2.plot(ax=ax, color='lightblue', markersize=10, alpha=0.5, zorder=1)
# edges2.plot(ax=ax, linewidth=1, edgecolor='grey', alpha=0.5, zorder=1)

# plt.scatter(error1[1], error1[0], c='pink', zorder=5, s=2)
# plt.scatter(error2[1], error2[0], c='orange', zorder=5, s=2)

#%% Setting up cost matrix

d = len(DEPOT_ID)
h = len(TRANSSHIPMENT_ID)
c = len(CUSTOMER_ID)

#cost matrix functions
c1 = []
for p in range(d):
    depot_closest_node = ox.nearest_nodes(waterway_network, DEPOT_xc[p], DEPOT_yc[p])
    c1.append(depot_closest_node)

c2 = []
for q in range(h):
    transshipment_closest_node1 = ox.nearest_nodes(waterway_network, TRANSSHIPMENT_xc[q], TRANSSHIPMENT_yc[q])
    c2.append(transshipment_closest_node1)    

c3 = []
for r in range(h):
    transshipment_closest_node2 = ox.nearest_nodes(bike_network, TRANSSHIPMENT_xc[r], TRANSSHIPMENT_yc[r])
    c3.append(transshipment_closest_node2)

c4 = []
for s in range(c):
    customer_closest_node = ox.nearest_nodes(bike_network, CUSTOMER_xc[s], CUSTOMER_yc[s])
    c4.append(customer_closest_node)

#cost matrix waterway network
c_total_water = c1 + c2

x1 = np.array(c_total_water)
y1 = np.array(c_total_water)

cost_mat_water = np.zeros((x1.shape[0], y1.shape[0]))

def f1(a,b):
    if t <= (d+h) and u <= (d+h):
        distance1 = nx.shortest_path_length(waterway_network, a, b, weight='length')
    return distance1

for t in range(x1.shape[0]):
    for u in range(y1.shape[0]):
        cost_mat_water[t,u] = f1(x1[t],y1[u])

#cost matrix bike network
c_total_bike  = c3 + c4

x2 = np.array(c_total_bike)
y2 = np.array(c_total_bike)

cost_mat_bike = np.zeros((x2.shape[0], y2.shape[0]))

def f2(a,b):
    if v <= (h-1) and w <= (h-1):
        distance2 = 0
    elif v > (h-1) or w > (h-1):
        distance2 = nx.shortest_path_length(bike_network, a, b, weight='length')
    return distance2

for v in range(x2.shape[0]):
    for w in range(y2.shape[0]):
        cost_mat_bike[v,w] = f2(x2[v],y2[w])

#add two matrixes together
c_total = c1 + c2 + c4

x3 = np.array(c_total)
y3 = np.array(c_total)

cost_mat_total = np.zeros((x3.shape[0], y3.shape[0]))

r,c = d,d
cost_mat_total[r:r + cost_mat_bike.shape[0], c:c + cost_mat_bike.shape[0]] = cost_mat_bike

r,c = 0,0
cost_mat_total[r:r + cost_mat_water.shape[0], c:c + cost_mat_water.shape[0]] = cost_mat_water

#round on 3 decimals
cost_mat_total_rounded = np.around(cost_mat_total, 3)

cm = pd.DataFrame(cost_mat_total_rounded.tolist())

#%% Customer characteristics

CUSTOMER_DEMAND = []
for i in range(hotels):
    CUSTOMER_DEMAND.append(hotel_demand)
for i in range(restaurants):
    CUSTOMER_DEMAND.append(restaurant_demand)
for i in range(cafes):
    CUSTOMER_DEMAND.append(cafe_demand)

CUSTOMER_S_TIME = [element * demand_time for element in CUSTOMER_DEMAND]

#%% Characteristics all together

LOC_ID = DEPOT_ID + TRANSSHIPMENT_ID + CUSTOMER_ID
xc = DEPOT_xc + TRANSSHIPMENT_xc + CUSTOMER_xc
yc = DEPOT_yc + TRANSSHIPMENT_yc + CUSTOMER_yc
S_TIME = DEPOT_S_TIME + TRANSSHIPMENT_S_TIME + CUSTOMER_S_TIME
DEMAND = DEPOT_DEMAND + TRANSSHIPMENT_DEMAND + CUSTOMER_DEMAND


#%% ----- Problem -----

model = Model('Two-Echelon Vehicle Routing Problem (2E-VRP)')

#%% ----- Data -----

d = len(DEPOT_ID)            #number of depots
h = len(TRANSSHIPMENT_ID)    #number of satellites
c = len(CUSTOMER_ID)         #number of customers
Q_v = 30                      #capacity vessel
Q_cb = 6                       #capacity cargo bike
MNOVA = 1                    #maximum number of vessels available
MNOCBA = 20                  #maximum number of cargo bikes available
M = 1000000

#%% ----- Sets and indices -----

D = [i for i in range (d)]                                  #set of depots
H = [i for i in range (d, d+h)]                             #set of satellites
C = [i for i in range (d+h, d+h+c)]                         #set of customers
N1 = D + H                                                  #set of nodes for 1st echelon
N2 = H + C                                                  #set of nodes for 2nd echelon
N = D + H + C                                               #set of all nodes
A = [(i, j) for i in N for j in N if i != j]                #set of arcs

K1 = [i for i in range(MNOVA)]                              #set of vessels
K2 = [i for i in range(MNOVA, MNOVA + MNOCBA)]              #set of cargo bikes
K = K1 + K2                                                 #set of vehicles

#%% ----- Parameters -----

#c = {(i, j): np.hypot(xc[i]-xc[j],yc[i]-yc[j]) for i, j in A}         #euclidean distance
c = {(i, j): cm[i][j] for i, j in A}                                  #time matrix distance
s = S_TIME                                                            #service time
q = {i: DEMAND[i] for i in N}                                         #demand of the customer

#%% ----- Decision variables -----

# R(i,j) - The route of the truck from customer i to j, 0 = donâ€™t visit, 1 = visit
x = {}
for i in N:
    for j in N:
        for k in K:
            x[i,j,k] = model.addVar (lb = 0, vtype = GRB.BINARY)
        
# T(i) - Time counter of elapsed time at the arrival of customer i	        
T = {}
for i in N:
    T[i] = model.addVar (lb = 0, vtype = GRB.CONTINUOUS)
    
# L(i) - Load counter    
L = {}
for i in N:
    L[i] = model.addVar (lb = 0, vtype = GRB.CONTINUOUS)

#%% ----- Objective function (minimize total distance) -----

Total_distance_travelled = quicksum (c[i,j]*x[i,j,k] for i in N for j in N if i != j for k in K)

model.setObjective (Total_distance_travelled)
model.modelSense = GRB.MINIMIZE
model.update ()

#%% ----- Constraints -----

#first echelon  

#M times number of incoming arcs at hub must be greater or equal to outgoing arcs at hub
con1_1 = {}
for j in H:
    con1_1[i,j,k] = model.addConstr((M * quicksum(x[i,j,k] for i in N1 for k in K1)) >= quicksum(x[j,i,k] for i in N2 for k in K2))

con3_1 = {}
for i in N1:
    for k in K1:
        con3_1[i,i,k] = model.addConstr(x[i,i,k] == 0)        
    
con4_1 = {}
for j in N1:
    for k in K1:
        con4_1[i,j,k] = model.addConstr(quicksum(x[i,j,k] for i in N1) == quicksum(x[j,i,k] for i in N1))
        
con5_1 = {}
for k in K1:
    con5_1[k] = model.addConstr(quicksum(x[h,j,k] for j in H for h in D) <= 1)

con6_1 = {}
for i in N1:
    for j in N1:
        if j >= d:
            if i != j:
                for k in K1:
                    con6_1[i,j,k] = model.addConstr(T[i] + ((c[i,j]*3.6)/v_v)*x[i,j,k] + s[i] - M*(1-x[i,j,k]) <= T[j])
                
con7_1 = {}
for i in N1:
    for j in N1:
        if j >= d:
            for k in K1:
                con7_1[i,j,k] = model.addConstr(L[i] - q[j] + M*(1-x[i,j,k]) >= L[j]) 

con8_1 = {}
for i in N1:
    con8_1[i] = model.addConstr(L[i] + q[i] <= Q_v)               

#-------------------------------------------------------

#second echelon
con1_2 = {}
for i in C:
    con1_2[i,j,k] = model.addConstr(quicksum(x[i,j,k] for j in N2 for k in K2) == 1)
    
con2_2 = {}
for j in C:
    con2_2[i,j,k] = model.addConstr(quicksum(x[i,j,k] for i in N2 for k in K2) == 1)
        
con3_2 = {}
for i in N2:
    for k in K2:
        con3_2[i,i,k] = model.addConstr(x[i,i,k] == 0)    

con4_2 = {}
for j in N2:
    for k in K2:
        con4_2[i,j,k] = model.addConstr(quicksum(x[i,j,k] for i in N2) == quicksum(x[j,i,k] for i in N2))

con5_2 = {}
for k in K2:
    con5_2[k] = model.addConstr(quicksum(x[h,j,k] for j in C for h in H) <= 1)    
 
con6_2 = {}
for i in N2:
    for j in N2:
        if j >= (d+h):
            if i != j:
                for k in K2:
                    con6_2[i,j,k] = model.addConstr(T[i] + ((c[i,j]*3.6)/v_cb)*x[i,j,k] + s[i] - M*(1-x[i,j,k]) <= T[j])

con7_2 = {}
for i in N2:
    for j in N2:
        if j >= (d+h):
            for k in K2:
                con7_2[i,j,k] = model.addConstr(L[i] - q[j] + M*(1-x[i,j,k]) >= L[j])

con8_2 = {}
for i in N2:
    con8_2[i] = model.addConstr(L[i] + q[i] <= Q_cb)            

#%% ----- Solve -----

model.update ()

model.setParam( 'OutputFlag', True) # silencing gurobi output or not
model.setParam ('MIPGap', 0);     # find the optimal solution (or within a percentage 0,05 = 5%, 0 = optimal)
model.write("output.lp")            # print the model in .lp format file

model.optimize ()

#%% ----- Results -----

print ('\n--------------------------------------------------------------------\n')
if model.status == GRB.Status.OPTIMAL:                          # If optimal solution is found
    print ('Minimal distance : %10.2f ' % model.objVal)
    print('\nFinished\n')
else:
    print ('\nNo feasible solution found\n')

active_arcs1 = [(i,j,k) for i in N1 for j in N1 if i != j for k in K1 if x[i,j,k].x == 1]
active_arcs2 = [(i,j,k) for i in N2 for j in N2 if i != j for k in K2 if x[i,j,k].x == 1]
print (('Route first echelon : '), sorted(active_arcs1))
print (('\nRoute second echelon : '), sorted(active_arcs2))

fig, ax = plt.subplots(figsize=(15,10), dpi=300)
plt.xlim([4.8614, 4.9356])
plt.ylim([52.3565, 52.3869])

for i, j, k in active_arcs1:
    plt.plot([xc[i], xc[j]], [yc[i], yc[j]], c='grey', zorder=0, linestyle='dashed', label='first echelon')
for i, j, k in active_arcs2:
    plt.plot([xc[i], xc[j]], [yc[i], yc[j]], c='grey', zorder=0, label='second echelon')
for d1 in range(d):
    plt.plot(xc[d1], yc[d1], c='black', marker='s', markersize=10, label='depot')
for d2 in range(d,d+h):
    plt.plot(xc[d2], yc[d2], c='grey', marker='s', markersize=10, label='transshipment location')

#plot hotels
plt.scatter(xc[d+h:d+h+hotels], yc[d+h:d+h+hotels], c='green', label='hotel')

#plot restaurants
plt.scatter(xc[d+h+hotels:d+h+hotels+restaurants], yc[d+h+hotels:d+h+hotels+restaurants], c='blue', label='restaurant')

#plot cafes
plt.scatter(xc[d+h+hotels+restaurants:d+h+hotels+restaurants+cafes], yc[d+h+hotels+restaurants:d+h+hotels+restaurants+cafes], c='red', label='cafe')

#plot legend without duplicates
handles, labels = plt.gca().get_legend_handles_labels()
by_label = dict(zip(labels, handles))
plt.legend(by_label.values(), by_label.keys())

#plot LOC_ID next to points
for i, txt in enumerate(LOC_ID):
    plt.annotate(txt, (xc[i], yc[i]), xytext=(xc[i]+0.0005, yc[i]+0.0005), bbox=dict(boxstyle="round", alpha=0.1))

#count number of vehicles necessary
total_vehicles1 = 0
active_arcs1_x = [x for x,y,k in active_arcs1]
for d1 in range(d):
    vehicles_first_echelon = active_arcs1_x.count(d1)
    total_vehicles1 = total_vehicles1 + vehicles_first_echelon
    print("\n                     Number of vessels departing from depot", d1, ": ", vehicles_first_echelon)
total_vehicles2 = 0
active_arcs2_x = [x for x,y,k in active_arcs2]
for d2 in range(d,d+h):
    vehicles_second_echelon = active_arcs2_x.count(d2)
    total_vehicles2 = total_vehicles2 + vehicles_second_echelon
    print("Number of cargo bikes departing from transshipment location", d2, ": ", vehicles_second_echelon)
print()
print("                                      Total vessels necessary : ", total_vehicles1)
print("                                  Total cargo bikes necessary : ", total_vehicles2) 

def time(t):
    new_time1 = ((dt.datetime.combine(dt.date(1,1,1),start_time) + dt.timedelta(seconds=round(t))).time())
    new_time2 = new_time1.strftime("%H:%M:%S")
    return new_time2

#print decision variable T = Time counter (TC) and L = Load counter (LC)
print ('\nArrival time at location:                Load after delivery at location:')
for d1 in range(d):
    print ('%28.0f' % LOC_ID[d1] + '%8.0f' % T[d1].x + '%38.0f' % LOC_ID[d1] + '%8.0f' % L[d1].x)
for d2 in range(d,d+h):
    print ('%28.0f' % LOC_ID[d2] + '%8.0f' % T[d2].x + '%38.0f' % LOC_ID[d2] + '%8.0f' % L[d2].x)
for i in C: 
    print ('%28.0f' % LOC_ID[i] + '%8.0f' % T[i].x + '%38.0f' % LOC_ID[i] + '%8.0f' % L[i].x)

#print real arrival times
print('\nReal arrival times:')
for d1 in range(d):
    print ('%28.0f' % LOC_ID[d1] , " ", time(T[d1].x))
for d2 in range(d,d+h):
    print ('%28.0f' % LOC_ID[d2] , " ", time(T[d2].x))
for i in C: 
    print ('%28.0f' % LOC_ID[i] , " ", time(T[i].x))





